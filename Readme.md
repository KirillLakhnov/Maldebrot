# Оптимизация фрактала Мандельброта

![Example 1](readme_files/maldebrot_picture.png)

## О ПРОЕКТЕ
В этом проекте я занимался оптимизацией алгоритма расчета множества Мандельброта, используя доступные на моем компьютере SIMD-инструкции такие, как SSE2, AVX2, AVX512, и флаги оптимизации компилятора, такие как -O1, -O2, -O3, -Ofast.

## Множество Мандельброта

**Множество Мандельброта** - это множество точек на плоскости таких, что для рекурсивных уравнений $x_{i+1} = x_i^2 - y_i^2 + x_0$ и $y_{i+1} = 2 * x_i * y_i+ y_0$ выполняется неравенство $R = (x^2 + y^2)^{1/2} >= R_{max}$, то есть функция $f(x_0, y_0) -> N$ ставит $(x_0, y_0)$ в соответствие число N - количество операций для нахождения таких x и y, что выполняется неравенство выше. Это множество является фрактальным.

### Алгоритм и его оптимизация 

Алгоритм расчета этого множества часто используется для оценки вычислительной скорости аппаратного обеспечения.

Размер вычисляемого множества 1280x720.

#### Код неоптимизированного алгоритма
```С++

const int XMax = 1280;
const int YMax = 720;
const int Nmax = 1000;

for (int dy = 0; dy < YMax; dy++)
{
    float y0 = (dy - cy)*scale;
    float x0 = (   - cx)*scale;

    for (int dx = 0; dx < XMax; dx++, x0 += scale)
    {
        int N = 0;

        float x = x0;
        float y = y0;

        while (N < NMax)
        {
            float x2 = x*x;
            float y2 = y*y;
            float xy = x*y;

            float r = x2 + y2;

            if (r > (RMAX)) 
            {
                break;
            }

            x = x2 - y2 + x0;
            y = 2*xy + y0;

            N++;
        }

        set_pixel (pixels, dx, dy, N); // Вычисляет цвет пикселя
    }
}
```
...

Производительность неоптимизированного алгоритма пропорциональна количеству пикселей. 

## Принципы оптимизации

Теперь оптимизируем данный код, используя набор команд SIMD-инструкции. Ознакомиться с командами можно на сайте: https://www.laruence.com/sse.

SIMD-инструкции специально разработаны для параллельных операций. Это делает их особенно полезными для нашего алгоритма. Они позволяют вести расчеты сразу для 4, 8, 16 пикселей в случаях SSE, AVX2, AVX512.

#### Код оптимизированного алгоритма (AVX2)
```С++

const int XMax = 1280;
const int YMax = 720;
const int Nmax = 1000;

const int VECT_SIZE_AVX2 = 8;

const __m256i NMAX = _mm256_set1_epi32 (NMax);

for (int dy = 0; dy < YMax; dy++)
{
    float y0 = (dy - cy) * scale;
    float x0 = (   - cx) * scale;

    for (int dx = 0; dx < XMax; dx += VECT_SIZE_AVX2, x0 += VECT_SIZE_AVX2 * scale)
    {
        __m256 X0 = _mm256_set_ps (x0 + 7 * scale, x0 + 6 * scale, x0 + 5 * scale, 
                                   x0 + 4 * scale, x0 + 3 * scale, x0 + 2 * scale, x0 + scale, x0);
        __m256 Y0 = _mm256_set1_ps (y0);

        __m256 X = X0;
        __m256 Y = Y0;

        __m256i  N = _mm256_setzero_si256 ();
        __m256 cmp = _mm256_setzero_ps ();
        __m256  X2 = _mm256_setzero_ps ();
        __m256  Y2 = _mm256_setzero_ps ();
        __m256  XY = _mm256_setzero_ps ();
        __m256   R = _mm256_setzero_ps ();

        int mask = 1;

        while (mask > 0)
        {
            mask = 0;

            X2 = _mm256_mul_ps (X, X);
            Y2 = _mm256_mul_ps (Y, Y);
            XY = _mm256_mul_ps (X, Y);
            R  = _mm256_add_ps (X2, Y2);

            X = _mm256_add_ps (_mm256_sub_ps (X2, Y2), X0);
            Y = _mm256_add_ps (_mm256_add_ps (XY, XY), Y0);

            cmp = _mm256_cmp_ps (RMAX, R, _CMP_GT_OQ);
            cmp = _mm256_and_ps (cmp, _mm256_castsi256_ps (_mm256_cmpgt_epi32 (NMAX, N)));

            N = _mm256_sub_epi32 (N, _mm256_castps_si256(cmp));
            mask = _mm256_movemask_ps (cmp);
        }

        for (int i = 0; i < VECT_SIZE_AVX2; i++)
        {
            int* N_int = (int*)(&N);
            set_pixel(pixels, dx + i, dy, N_int[i]);
        }
    }
}

```
## Результаты оптимизаций

В таблице ниже приведены значения FPS, измеренные для различных режимов оптимизации:

|Оптимизаиция \ Флаг|НЕТ |-O0 |-O1 |-O2 |-O3 |-Ofast |
|:------------------|:--:|:--:|:--:|:--:|:--:|:-----:|
|БЕЗ оптимизаций    |1.2 |1.2 |1.9 |2.1 |2.1 |2.2    |
|                   |    |    |    |    |    |       |
|Массивы пикселей   |0.3 |0.2 |1.1 |7.4 |7.4 |7.7    |
|                   |    |    |    |    |    |       |
|SSE инструкции     |1.9 |1.9 |4.5 |6.0 |6.0 |6.2    |
|                   |    |    |    |    |    |       |
|AVX2 инструкции    |2.9 |2.9 |5.5 |9.0 |9.0 |9.1    |
|                   |    |    |    |    |    |       |
|AVX512 инструкции  |4.0 |4.0 |6.4 |11.8|11.9|12.1   |

## Вывод
Оптимизация алгоритма рисования множества Мандельброта с использованием инстукций AVX512 позволяет его ускорить в **12.1/2.2 = 5.5** раз
